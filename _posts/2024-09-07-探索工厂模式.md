---
title: 探索工厂模式
toc: true
toc_sticky: true
tags: 
  - 设计模式
  - 工厂模式
categories:
  - 设计模式
---

## 初探工厂

如果我们想获得一个对象（例：ID 生成器），最直观的方式，就是使用构造器进行实例化。

```java
// 获取一个 ID 生成器
IdGenerator idGenerator = new 
 SimpleIdGenerator();
```

这在开发中，往往是最常用的一种方式。但是，试想这种方式的缺点是什么？

在解决业务需求时，无法忽视一个事实——不论软件设计的多好，一段时间后，总是需要成长与改变。当 ID 不再局限于一种简单类型呢？

```java
IdGenerator idGenerator;

if (isSimple()) {
    idGenerator = new SimpleIdGenerator();
} else if (isTypeA()) {
    idGenerator = new TypeAIdGenerator();
} else {
    idGenerator = new TypeZIdGenerator();
}
```

延续最开始的思路，我们会这样让代码跟上需求的发展。但是如果后续又有新的变化，我们就要重新打开这段代码进行修改，导致这段代码越来越多`if else`，越来越难维护。

此时，我们就应该去思考，如何**找出应用中可能需要变化之处，把它们独立出来**。

介绍一个设计原则：

> 针对接口（超类型）编程，而不是针对实现编程。

根据这个设计原则，有没有想到更好的解决方案呢？

假设是一个 ID 生成器是一个接口。

``` java 
@Data
public interface IdGenerator {

    // 构造 ID 生成上下文
    Context buildContext();

    // 生成 ID
    Id generate(Context context);
}
```

获取多种类型的 ID 时，使用如下方法。

```java
public Id getId(Integer idType) {
    IdGenerator idGenerator;

    //region 第一部分
    if (Objects.equals(idType, IdTypeEnum.Simple.getCode())) {
        idGenerator = new SimpleIdGenerator();
    } else if (Objects.equals(idType, IdTypeEnum.TypeA.getCode())) {
        idGenerator = new TypeAIdGenerator();
    } else {
        idGenerator = new TypeZIdGenerator();
    }
    //endregion

    //region 第二部分
    Context context = idGenerator.buildContext();
    return idGenerator.generate(context);
    //endregion
}
```

当新类型的 ID 生成器需要添加时，显然第一部分需要调整，而第二部分是不需要改动的。所以，第一部分是可能变化之处，而第二部分是不变之处。因此，我们需要将第一部分独立出来。

```java
public class IdGeneratorFactory {
    public IdGenerator createIdGenerator(Integer idType) {
        if (Objects.equals(idType, IdTypeEnum.Simple.getCode())) {
            idGenerator = new SimpleIdGenerator();
        } else if (Objects.equals(idType, IdTypeEnum.TypeA.getCode())) {
           idGenerator = new TypeAIdGenerator();
        } else {
            idGenerator = new TypeZIdGenerator();
        }
    }
}
```

表面来看，我们只是把相同的代码搬进了一个单独的类，难以维护的问题并没有得到解决。实际上，我们将生产 IdGenerator 的方法单独维护到了这个类中，我们不必每次创建 IdGenerator 的时候都复制一份 `if else` 的冗长代码。

我们使用 IdGeneratorFactory 对刚才的代码进行重构。

```java
public class SomeClass {
    
    private final IdGeneratorFactory factory;

    public SomeClass(IdGeneratorFactory factory) {
        this.factory = factory; 
    }

    public Id getId(Integer idType) {
        IdGenerator idGenerator;

        //region 第一部分(已优化)
        idGenerator = factory.createIdGenerator(idType);
        //endregion

        //region 第二部分
        Context context = idGenerator.buildContext();
        return idGenerator.generate(context);
        //endregion
    }
} 
```

如上，我们就完成了一个“简单工厂”，但是遗憾的是“简单工厂”并不能算是一个设计模式，可以说是一种编程习惯。就让“简单工厂”来为我们引入接下来真正的工厂模式吧！

## 工厂方法


