---
title: 探索工厂模式
toc: true
toc_sticky: true
tags: 
  - 设计模式
  - 工厂模式
categories:
  - 设计模式
---

## 初探工厂

如果我们想获得一个对象（例：ID 生成器），最直观的方式，就是使用构造器进行实例化。

```java
// 获取一个 ID 生成器
IdGenerator idGenerator = new 
 SimpleIdGenerator();
```

这在开发中，往往是最常用的一种方式。但是，试想这种方式的缺点是什么？

在解决业务需求时，无法忽视一个事实——不论软件设计的多好，一段时间后，总是需要成长与改变。当 ID 不再局限于一种简单类型呢？

```java
IdGenerator idGenerator;

if (isSimple()) {
    idGenerator = new SimpleIdGenerator();
} else if (isTypeA()) {
    idGenerator = new TypeAIdGenerator();
} else {
    idGenerator = new TypeZIdGenerator();
}
```

延续最开始的思路，我们会这样让代码跟上需求的发展。但是如果后续又有新的变化，我们就要重新打开这段代码进行修改，导致这段代码越来越多`if else`，越来越难维护。

此时，我们就应该去思考，如何**找出应用中可能需要变化之处，把它们独立出来**。

介绍一个设计原则：

> 针对接口（超类型）编程，而不是针对实现编程。

根据这个设计原则，有没有想到更好的解决方案呢？

假设是一个 ID 生成器是一个接口。

``` java 
@Data
public interface IdGenerator {

    // 构造 ID 生成上下文
    Context buildContext();

    // 生成 ID
    Id generate(Context context);
}
```

获取多种类型的 ID 时，使用如下方法。

```java
Id getId(Integer idType) {
    IdGenerator idGenerator;

    //region 第一部分
    if (Objects.equals(idType, IdTypeEnum.Simple.getCode())) {
        idGenerator = new SimpleIdGenerator();
    } else if (Objects.equals(idType, IdTypeEnum.TypeA.getCode())) {
        idGenerator = new TypeAIdGenerator();
    } else {
        idGenerator = new TypeZIdGenerator();
    }
    //endregion

    //region 第二部分
    Context context = idGenerator.buildContext();
    return idGenerator.generate(context);
    //endregion
}
```

当新类型的 ID 生成器需要添加时，显然第一部分需要调整，而第二部分是不需要改动的，所以，第一部分是可能变化之处，而第二部分是不变之处。因此，我们需要将第一部分独立出来。


